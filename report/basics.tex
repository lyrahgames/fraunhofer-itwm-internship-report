\documentclass[crop=false]{standalone}
\usepackage{standard}

\begin{document}
  \section{Grundlagen und der naive Algorithmus} % (fold)
  \label{sub:naiver_algorithmus}
    Abbildung \ref{fig:raytracing} stellt eine Skizze des grundsätzlichen Algorithmus dar.
    Für jeden Pixel des Pixelpuffers wird ein Strahl von der Kameraposition durch den Pixel in die Richtung des Bildschirms ausgesendet.
    Jeder dieser Strahlen wird dann mit der Szene auf Schnittpunkte getestet.
    Existiert ein Schnittpunkt, so wird dieser durch weitere Algorithmen dargestellt.
    Existieren mehrere Schnittpunkte, so wird derjenige ausgewählt, der der Kamera am nächsten ist.
    \begin{figure}[h]
      \center
      \includegraphics[width=0.8\textwidth]{images/ray_tracing_scheme.pdf}
      \caption{%
        Die Skizze stellt das Raytracing-Verfahren dar.
        Bezüglich eines Beobachtungspunktes $o$ wird durch jeden Pixel eines virtuellen Bildschirms $\mathrm{VS}$ ein Strahl geschossen.
        Die grau melierten Dreiecke stellen dabei die Szene dar.
        Jeder Pixel des virtuellen Bildschirms entspricht einem analogen Pixel des realen Bildschirms.
      }
      \label{fig:raytracing}
    \end{figure}

    \subsection{Aufbau der Kamera} % (fold)
    \label{sub:aufbau_der_kamera}
      Für die Implementierung wurde das Einlesen der Szene als Liste von Dreiecken wie in Abschnitt \ref{ssub:einlesen_der_daten} realisiert.
      Die Kamera konnte mithilfe einer Klasse dargestellt werden.
      In der folgenden Abbildung \ref{fig:camera-scheme} ist die Bedeutung der einzelnen Parameter skizziert.
      \begin{figure}[h]
        \center
        \includegraphics[width=0.8\textwidth]{images/camera_scheme.pdf}
        \caption{%
          Die Abbildung veranschaulicht die Parameter der Klasse \texttt{Camera} anhand einer Skizze.
          Das Tupel $\roundBrackets{e_0,\set{e_1,e_2,e_3}{}}$ beschreibt die affine Basis, $n_\mathrm{w}$ und $n_\mathrm{h}$ die Breite und die Höhe des virtuellen Bildschirms in Pixeln und $α$ den Öffnungswinkel (engl.: \textit{field of view}).
        }
        \label{fig:camera-scheme}
      \end{figure}
      Die Position und Ausrichtung der Kamera wurde durch eine positiv orientierte affine Basis im $\setReal^3$ beschrieben.
      Der erste Basisvektor zeigt in die Richtung, die für die Kamera als rechts definiert ist.
      Analoges gilt für den zweiten und dritten Basisvektor bezüglich den Richtungen oben und hinten.
      Der zu einer Kamera gehörige virtuelle Bildschirm wurde durch die Anzahl seiner Pixel $n_\mathrm{w}$ und $n_\mathrm{h}$ in der Breite und Höhe charakterisiert.
      Die Entfernung zur Kamera wurde durch den Öffnungswinkel $\alpha$ (engl.: \textit{field of view}), unter dem die Höhe des Bildschirms von der Kamera aus zu sehen ist, angegeben.
      Weitere Größen wie die Kantenlänge $p$ eines Pixels im Raum oder das Seitenverhältnis $r$ des virtuellen Bildschirms lassen sich aus den bereits definierten Größen eindeutig berechnen.
      \[
        p = \frac{2\tan \frac{\alpha}{2}}{n_\mathrm{h}}
        \qquad
        r = \frac{n_\mathrm{w}}{n_\mathrm{h}}
      \]
    % subsection aufbau_der_kamera (end)

    \subsection{Strahl-Dreieck-Schnittpunkttest} % (fold)
    \label{sub:strahl_dreieck_schnittpunkttest}
      Die von der Kamera ausgesendeten Primärstrahlen mussten auf Schnittpunkte mit der Szene getestet werden.
      Für jeden Strahl wurden hierfür mithilfe des Möller-Trumbore-Verfahrens die Schnittpunkte mit allen Dreiecken der Szene berechnet.
      Um das genannte Verfahren genauer zu erklären, seien $A,B,C\in \setReal^3$ die Eckpunkte eines Dreiecks, wobei gilt, dass die Menge $\left\{ B-A,C-A \right\}$ linear unabhängig ist.
      Wie sich leicht überprüfen lässt, lassen sich alle Punkte des Dreiecks durch die folgende Parametrisierung beschreiben.
      \begin{align*}
        &M \define \set{ (u,v)\in [0,1]^2 }{ u+v \leq 1 } \\
        &\function{\varphi}{M}{\mathds{R}^3}
        \separate
        \varphi(u,v)\define (1-u-v)A + uB + vC
      \end{align*}
      Die Koordinaten $u$, $v$ und $1-u-v$ werden auch als die baryzentrischen Koordinaten eines Dreiecks bezeichnet.
      Weiterhin nehmen wir an, dass ein Strahl durch die folgende Funktion $r$, den Ursprung $o\in\mathds{R}^3$ und die Richtung $d\in\mathds{R}^3\setminus\{0\}$ beschrieben wird.
      \[
        \function{r}{[0,\infty)}{\mathds{R}^3}
        \separate
        r(t) \define o + td
      \]
      Für einen Schnittpunkt zwischen Strahl und Dreieck muss die folgende Gleichung für s$(u,v)\in M$ und $t\in[0,\infty)$ erfüllt sein.
      \[
        o + td = A + (B-A)u + (C-A)v
      \]
      Durch Umbenennung lässt sich diese Gleichung etwas vereinfachen.
      \[
        e_0 = ue_1 + ve_2 - td
      \]
      \[
        e_0 \coloneqq o - A
        \qquad
        e_1 \coloneqq B-A
        \qquad
        e_2 \coloneqq C-A
      \]
      Fasst man nun die Koordinaten $u$, $v$ und $t$ zu einem Vektor zusammen, so lässt sich die Gleichung sehr elegant durch ein Matrix-Vektor-Produkt formulieren.
      \[
        e_0 =
        \begin{pmatrix}
          e_1 &
          e_2 &
          -d
        \end{pmatrix}
        \begin{pmatrix}
          u \\
          v \\
          t
        \end{pmatrix}
      \]
      Dieses lineare Gleichungssystem ist genau dann lösbar, wenn die Determinante der Matrix ungleich Null ist.
      \[
        \begin{pmatrix}
          u \\
          v \\
          t
        \end{pmatrix}
        =
        \begin{pmatrix}
          e_1 &
          e_2 &
          -d
        \end{pmatrix}^{-1}
        e_0
      \]
      Die inverse der Matrix lässt sich analytisch leicht durch Skalar- und Kreuzprodukte beschreiben.
      Diese ermöglichen zudem eine effiziente Berechnung.
      \[
        \begin{pmatrix}
          u \\
          v \\
          t
        \end{pmatrix}
        =
        \frac{1}{\left\langle e_1, d\times e_2  \right\rangle}
        \begin{pmatrix}
          \left\langle d\times e_2 , e_0 \right\rangle \\
          \left\langle e_1\times d , e_0 \right\rangle \\
          \left\langle e_1\times e_2, e_0 \right\rangle
        \end{pmatrix}
        =
        \frac{1}{\left\langle e_1, d\times e_2  \right\rangle}
        \begin{pmatrix}
          \left\langle d\times e_2 , e_0 \right\rangle \\
          \left\langle e_0\times e_1 , d \right\rangle \\
          \left\langle e_0\times e_1, e_2 \right\rangle
        \end{pmatrix}
      \]
      Durch diese Gleichung lassen sich nun die Parameter $u$, $v$ und $t$ bestimmen.
      Es muss überprüft werden, ob diese auch die Bedingungen der Parametrisierungen erfüllen.
      \[
        \left\langle e_1, d\times e_2  \right\rangle \neq 0
        \qquad
        u,v,t \geq 0
        \qquad
        u+v\leq 1
      \]
      Sind die Bedingungen erfüllt, so liegt ein Schnittpunkt vor.
      Implementiert wurde dieser Algorithmus durch den folgenden Quelltext.

      \inputCodeBlock[title=Möller-Trumbore-Algorithmus]{code/moeller_trumbore_intersection.cc}
    % subsection strahl_dreieck_schnittpunkttest (end)
  % section naiver_algorithmus (end)
\end{document}