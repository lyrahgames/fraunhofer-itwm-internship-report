\documentclass[crop=false]{standalone}
\usepackage{standard}

\begin{document}
  \section{Beschleunigungsstrukturen, Optimierung und weitere Features} % (fold)
  \label{sec:beschleunigungsstrukturen_optimierung_und_weitere_features}
    Auf den in Abschnitt \ref{sec:basics} beschriebenen Grundlagen bauten alle weiteren Optimierungen und Features auf.
    Ich habe mich mit diesem Projekt innerhalb meiner Arbeitsgruppe seit über vier Jahren beschäftigt und folglich einige Verbesserungen vorgenommen, sowie Messungen durchgeführt und Erfahrungen gesammelt.
    Die genaue Beschreibung der Lösungsmethoden und Ergebnisse aller Veränderungen würde über den Rahmen dieses Berichts hinausgehen.
    Demzufolge sind im Folgenden viele der Features und Optimierungen in einer kürzeren Form dargestellt.
    So ist es mir möglich, eine verständliche Zusammenfassung der Arbeit am Projekt zu vermitteln.

    \subsection{Linear Bounding Volume Hierarchies} % (fold)
    \label{sub:linear_bounding_volume_hierarchies}
      Beschleunigungsstrukturen stellen eines der Kernelemente eines jeden Raytracers dar und funktionieren unabhängig von der Hardware.
      Ohne Algorithmen, die die Anzahl der Schnittpunkttests für jeden Strahl reduzieren, wäre die Zeit einen einzelnen Strahl durch die Szene zu schießen proportional zur Anzahl der Dreiecke.
      In den meisten Fällen handelt es sich hierbei jedoch um Zeitverschwendung, da ein Strahl die überwiegende Mehrheit der Dreiecke gar nicht schneidet.
      Das Ziel von Beschleunigungsstrukturen besteht darin, Gruppen von nicht-schneidenden Dreiecken schnell zu verwerfen und die Übrigen zu sortieren, um nahegelegene Dreiecke zu bevorzugen.

      \textit{Bounding Volume Hierachies} (BVH) sind Beschleunigungsstrukturen.
      Sie unterteilen eine gegebene Szene in eine Hierarchie von disjunkten Mengen von Dreiecken.
      Abbildung \ref{fig:bvh-scheme} zeigt diese Methode anhand zweier Skizzen.
      Dreiecke werden in den Blättern der Hierarchie gespeichert, während sogenannte \textit{Bounding Boxes} die Knoten zwischen den Blättern füllen.
      Ein Strahl traversiert den Baum indem in jedem Knoten, an welchem er vorbeikommt, einen Schnittpunkttest mit der \textit{Bounding Box} durchführt.
      Fällt der Test negativ aus, so wird der Knoten mit seinen Kindern verworfen.
      \begin{figure}[h]
        \center
        \begin{subfigure}[b]{0.49\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/bvh_bounding_boxes.pdf}
        \end{subfigure}
        \begin{subfigure}[b]{0.49\textwidth}
          \center
          \includegraphics[width=0.75\textwidth]{images/bvh_tree.pdf}
        \end{subfigure}
        \caption{%
          Die Abbildungen zeigen die skizzenhafte Darstellung einer möglichen BVH einer Szene bestehend aus den Dreiecken $\triangle_1$, $\triangle_2$, $\triangle_3$ und $\triangle_4$.
          Im linken Bild sind die \textit{Bounding Boxes} der BVH und im rechten Bild deren zugehörige Verknüpfungen im Sinne eines Baums gezeigt.
        }
        \label{fig:bvh-scheme}
      \end{figure}

      Um die Schnittpunktberechnung zwischen Strahl und \textit{Bounding Box} so weit wie möglich zu vereinfachen, werden an den Koordinatenachsen ausgerichtete \textit{Bounding Boxes} (AABB, engl.: \textit{axis-aligned bounding box}) verwendet.
      Diese lassen sich eindeutig durch die Angabe zweier ihrer gegenüberliegenden Eckpunkte beschreiben.
      Eine AABB beschreibt damit einen Quader im Raum.
      Aus diesem Grund muss für jede der sechs Flächen ein Schnittpunkttest durchgeführt werden.
      Durch die Ausrichtung an den Koordinatenachsen vereinfachen sich diese sechs Tests jedoch zu einer Division, sechs Additionen und sechs Multiplikationen.

      Um BVHs zu konstruieren lassen sich diverse Algorithmen verwenden.
      Im Projekt wählte ich eine Methode, die sowohl auf der CPU als auch GPU effizient funktionieren sollte.
      \textit{Linear Bounding Volume Hierarchies} (LBVH) können in linearer Zeit bezüglich der Anzahl der Dreiecke konstruiert werden.
      Sie sind vergleichsweise einfach parallelisierbar und skalieren sowohl auf der CPU als auch auf der GPU.

      Die Idee besteht darin, die Konstruktion einer LBVH auf ein Sortierverfahren zurückzuführen.
      Da es im dreidimensionalem Raum keine eindeutig ausgezeichnete Ordnung gibt, verwendet man \textit{Morton Codes}.
      Diese bilden naheliegende dreidimensionale Punkte auf naheliegende eindimensionale Punkte entlang einer Kurve ab.
      Aufgrund ihrer charakteristischen Form wird diese Kurve auch die Z-Kurve genannt.
      Abbildung \ref{fig:morton-curve-scheme} zeigt den Verlauf der Morton-Kurve für zwei unterschiedlich feine Gitter.
      Zudem zeigt sie, dass \textit{Morton Codes} auf einer simplen Transformation basieren.
      Gegeben sei für ein $n\in\setNatural$ ein Tupel natürlicher Zahlen $k\in\setNatural_0^n$.
      Die Binärdarstellung einer Koordinate $k_i$ für $i\in\setNatural_0$ mit $i<n$ sei gegeben durch
      \[
        k_i = (\cdots k_{i3}\, k_{i2}\, k_{i1}\, k_{i0})_2
      \]
      In diesem Falle berechnet sich der \textit{Morton Code} $m(k)$ von $k$ durch den folgenden Ausdruck.
      \[
        m(k) \define (\cdots k_{22}\, k_{12}\, k_{02}\cdots k_{21}\, k_{11}\, k_{01}\cdots k_{20}\,k_{10}\,k_{00})_2
      \]
      Durch die Verwendung von \textit{Radix Sort} und der \textit{Morton Codes} der Dreiecksmittelpunkte lässt sich nun durch ein \textit{Bottom-Up}-Verfahren die BVH effizient und parallel konstruieren.
      \begin{figure}[h]
        \center
        \begin{subfigure}[c]{0.49\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/morton_curve_1.pdf}
        \end{subfigure}
        \begin{subfigure}[c]{0.478\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/morton_curve_2.pdf}
        \end{subfigure}
        \caption{%
          Die Abbildung zeigt den Verlauf der Morton-Kurve durch die Szene für zwei unterschiedliche Verfeinerungsgrade der Gitter.
        }
        \label{fig:morton-curve-scheme}
      \end{figure}

      Die Struktur einer BVH führt dazu, dass die Laufzeitkomplexität im Durchschnitt logarithmisch statt linear in der Anzahl der Dreiecke verläuft.
      Dies führte zu einer dramatischen Verbesserung der vorherigen Ergebnisse.
      Abbildung \ref{fig:lbvh-results} zeigt vier der im Projekt verwendeten hochkomplexen Modelle.
      Jede Szene konnte durch User-Interaktion mit durchschnittlich $50\appendUnit{FPS}$ rotiert werden.
      Damit übertraf die Verwendung der LBVH jede meiner Erwartungen.
      Auch die Konstruktion der LBVH war innerhalb von ein paar Millisekunden abgeschlossen.
      Doch auch dieser extrem performante Build-Prozess offenbarte nach genaueren Messungen einige Schwachstellen.
      Die entstehende BVH stellt keine optimale BVH der Szene dar.
      Sobald sich die Kamera innerhalb eines Objektes befand, verlangsamte sich das gesamte Rendering.
      Im Verlauf des Projektes wurden innerhalb meiner Arbeitsgruppe weitere Verfahren zur Konstruktion von BVHs eingebaut.
      Es scheint als würden die besten Bäume durch hybride Verwendung von mehreren Methoden entstehen.
      \begin{figure}[h]
        \center
        \begin{subfigure}[b]{0.24\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/thai_statue.png}
          \caption{\textit{Thai Statue}}
        \end{subfigure}
        \begin{subfigure}[b]{0.24\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/dragon.png}
          \caption{\textit{Chinese Dragon}}
        \end{subfigure}
        \begin{subfigure}[b]{0.24\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/predator.png}
          \caption{\textit{Predator}}
        \end{subfigure}
        \begin{subfigure}[b]{0.24\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/half_heart.png}
          \caption{\textit{Half Heart}}
        \end{subfigure}
        \caption{%
          Die Abbildungen zeigen vier Modell, welche durch den Raytracer gerendert wurden.
          Aufgrund der extrem hohen Dreiecksanzahl war es erst durch die Verwendung einer Beschleunigungsstruktur, wie der LBVH, möglich diese Bilder in Echtzeit zu generieren.
        }
        \label{fig:lbvh-results}
      \end{figure}

    % subsection linear_bounding_volume_hierarchies (end)

    \subsection{Path Tracing} % (fold)
    \label{sub:path_tracing}
      Da der Raytracer vor allem der Visualisierung dienen sollte, war es nötig den Lichttransport innerhalb einer Szene zu simulieren.
      In der Theorie wird die Simulation von Lichtverteilungen durch die Rendergleichung (engl.: \textit{rendering equation} oder \textit{light transport equation}) beschrieben.
      Dabei handelt es sich um eine Fredholm-Integralgleichung 2.~Art für die Strahldichte der gesamten Szene.
      Sie kann mithilfe der Energieerhaltung und Theoremen der geometrischen Optik und Radiometrie hergeleitet werden.
      Im Allgemeinen besitzt dieses Gleichung keine geschlossene Lösung.
      Ihre Verwendung bedingt zudem die Implementierung von physikalischen Materialien, die Licht reflektieren, absorbieren und brechen.
      Die Materialien beschreiben dabei die genaue Interaktion von Lichtstrahlen mit den Oberflächen von Objekten durch bidirektionale Streuungsverteilungsfunktionen (BSDF, engl.: \textit{bidirectional scattering distribution function}).

      Eine BSDF gibt an, welcher Anteil des einfallenden Lichtes bezüglich der Einfallsrichtung in eine bestimmte Richtung gestreut wird.
      Sie stellt damit eine Verallgemeinerung der idealen Reflexion und Brechung an Oberflächen dar.
      Die Konstruktion komplexer Materialien erfolgte zumeist durch Bildung einer Linearkombination bereits bekannter und gut beschreibbarer BSDFs, wie der Lambertsch diffuse Strahler oder die \textit{Glossy Reflection}, sodass diese effizient durch die Speicherung von Koeffizienten implementiert werden konnten.

      Für die numerische Lösung der Rendergleichung transformiert man diese in ihre Pfadintegral-Formulierung.
      Die Integrale lassen sich nun durch Monte-Carlo Methoden erwartungstreu schätzen.
      Trifft ein Primärstrahl auf die Oberfläche, so wird durch die randomisierte \textit{Russian Roulette}-Methode entschieden, ob dieser Strahl reflektiert, absorbiert oder transmittiert wird.
      Auf der Basis dieser Entscheidung wird eine neuer zufälliger Strahl auf der entsprechenden Hemisphäre generiert, der wiederum den kompletten \textit{Path Tracing}-Prozess durchläuft.
      Um die Farbe eines Pixels mit einem geringen Fehler zu schätzen, ist es notwendig eine große Anzahl dieser Pfade auszuwerten.

      Abbildung \ref{fig:path-tracing-results} zeigt diverse durch \textit{Path Tracing} generierte Bilder.
      Je nach Beleuchtung und Aufbau einer Szene konvergiert der Algorithmus unterschiedlich schnell.
      Vor allem im Inneren von Objekten muss eine enorm lange Zeit vergehen, bis ein akzeptables Ergebnis zu sehen ist.
      Es konnte leider nicht gemessen werden, ob die simulierten Ergebnisse auch der Wirklichkeit entsprachen.
      Dennoch schienen die Bilder für das menschliche Auge durchaus realistische und nicht Computer generiert.
      \begin{figure}[h]
        \center
        \begin{subfigure}[b]{0.614\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/path_tracing-audi_r8.png}
          \caption{\textit{Audi R8}}
        \end{subfigure}
        \begin{subfigure}[b]{0.38\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/path_tracing-dragon.png}
          \caption{\textit{Chinese Dragon}}
        \end{subfigure}

        \begin{subfigure}[b]{0.635\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/path_tracing-shaderball.png}
          \caption{\textit{Shaderball}}
        \end{subfigure}
        \begin{subfigure}[b]{0.358\textwidth}
          \center
          \includegraphics[width=0.95\textwidth]{images/path_tracing-cornell_box.png}
          \caption{\textit{Cornell Box}}
        \end{subfigure}
        \caption{%
          Die Abbildungen wurden mithilfe des hier implementierten \textit{Path Tracing}-Verfahrens für verschiedene Modelle erzeugt.
          Die Materialien der Modelle wurden durch ideale Reflexionen, Brechungen und Lambertsche Strahler beschrieben.
          Für jeden Pixel wurden 1024 zufällige Pfade ausgewertet.
        }
        \label{fig:path-tracing-results}
      \end{figure}


      \subsubsection{Quasi-Monte-Carlo-Methoden} % (fold)
      \label{ssub:monte_carlo_methoden}

      % subsubsection monte_carlo_methoden (end)

      \subsubsection{Light Caching} % (fold)
      \label{ssub:light_caching}

      % subsubsection light_caching (end)

      \subsubsection{Reflexions- und Brechungsmodelle} % (fold)
      \label{ssub:reflexions_und_brechungsmodelle}

      % subsubsection reflexions_und_brechungsmodelle (end)
    % subsection path_tracing (end)

    \subsection{Optimierungen auf CPU} % (fold)
    \label{sub:optimierungen_auf_cpu}
      \subsubsection{Threadpools, OpenMP, mctp} % (fold)
      \label{ssub:threadpools}

      % subsubsection threadpools (end)

      \subsubsection{SIMD intrinsics} % (fold)
      \label{ssub:simd_intrinsics}

      % subsubsection simd_intrinsics (end)
    % subsection optimierungen_auf_cpu (end)
  % section beschleunigungsstrukturen_optimierung_und_weitere_features (end)
\end{document}